Index: aigeanpy/satmap.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from typing import Union\nfrom pathlib import Path\nfrom aigeanpy.utils import earth_to_pixel, pixel_to_earth\nimport numpy as np\nfrom datetime import datetime\nfrom skimage.transform import rescale, downscale_local_mean, resize\nimport os\nimport matplotlib.pyplot as plt\nimport json\n\nfrom aigeanpy.read import *\n\n\n\n\nclass SatMap:\n    \"\"\"\n\n\n    \"\"\"\n\n    def __init__(self, meta, data, shape, fov, centre):\n        self.meta = meta\n        self.data = data\n        self.shape = shape\n        self.fov = fov\n        self.centre = centre\n\n\n    # support the + and - operation\n    def __add__(self, other: 'SatMap'):\n        \"\"\"self defined + operation, collate two images and create the new SatMap instance (i.e, if we got an image\n            covering the (0,0)-(10,10) range and another from (12, 5)-(22,15), then we would end up with a “canvas”\n            that goes from (0,0)-(22,15).)\n\n        Parameters\n        ----------\n        other: SatMap\n               Another image to be added to the current image\n\n        Notes\n        -----\n        When the two images are overlapping, the values of the overlapping areas should not be added. Otherwise\n        it would give the wrong impression. Values should be the same when observed the same day.\n\n        Returns\n        -------\n        result: SatMap\n                the image created by the addition of two input images\n        \"\"\"\n\n        # error raising: query using wrong data format\n        if type(other) != SatMap:\n            raise TypeError(\"The attribute other must be a SatMap instance.\")\n\n        # check if the two images can be added or not\n        if self.meta['date'] != other.meta['date']:\n            raise TypeError(\"only the images from the same day can be added\")\n\n        if self.meta['instrument'] != other.meta['instrument']:\n            raise TypeError(\"only the images from the same instrument can be added\")\n\n        # convert both of two image pixel data into earth coord\n        earthA = pixel_to_earth(self.data, self.meta)\n        earthB = pixel_to_earth(other.data, other.meta)\n\n        coordA = earthA['earthCoord']\n        coordB = earthB['earthCoord']\n\n        # specify the boundary of final combined result (top-left, bottom-right)\n        xLowA, xHighA = self.meta['xcoords']\n        yLowA, yHighA = self.meta['ycoords']\n\n        xLowB, xHighB = other.meta['xcoords']\n        yLowB, yHighB = other.meta['ycoords']\n\n        xLow, xHigh = min(xLowA, xLowB), max(xHighA, xHighB)\n        yLow, yHigh = min(yLowA, yLowB), max(yHighA, yHighB)\n\n        # do the add logic\n        data = np.zeros((int(yHigh - yLow), int(xHigh - xLow)))\n        data[int(yLowA-yLow):int(yHighA-yLow), int(xLowA-xLow):int(xHighA-xLow)] = coordA\n        data[int(yLowB-yLow):int(yHighB-yLow), int(xLowB-xLow):int(xHighB-xLow)] = coordB\n        data = earth_to_pixel(data, self.meta)\n\n        # create the new SatMap instance to store the result\n        shape = data.shape\n        fov = (xHigh - xLow, yHigh - yLow)\n        centre = ((xHigh+xLow)/2, (yHigh+yLow)/2)\n\n        now = datetime.now()\n\n        meta = dict()\n        meta['archive'] = self.meta['archive']\n        meta['year'] = now.year\n        meta['observatory'] = self.meta['observatory']\n        meta['instrument'] = self.meta['instrument']\n        meta['date'] = now.date()\n        meta['time'] = now.time()\n        meta['xcoords'] = [xLow, xHigh]\n        meta['ycoords'] = [yLow, yHigh]\n        meta['resolution'] = self.meta['resolution']\n        # add the extra property, indicating the source of the image (add/subtract/mosaic/origin)\n        meta['source'] = \"add\"\n\n        # return the new SatMap instance\n        return SatMap(meta, data, shape, fov, centre)\n\n    def __sub__(self, other: 'SatMap'):\n        \"\"\"self defined - operation, obtain a difference image to measure change between the days, which will only work\n            when the data is overlapping. (i.e, if we have taken an image yesterday covering (0,0)-(10,10), and today\n            another in the range of (5, 5)-(15, 15), the resultant image should be the difference between the both for\n            the range (5, 5)-(10, 10).)\n\n        Parameters\n        ----------\n        other: SatMap\n               Another image to be subtracted from the current image\n\n        Notes\n        -----\n        Two images must be taken from different days. And they must overlap with each other\n\n        Returns\n        -------\n        result: SatMap\n                the image created by the subtraction of two input images\n        \"\"\"\n\n        # error raising: query using wrong data format\n        if type(other) != SatMap:\n            raise TypeError(\"The attribute other must be a SatMap instance.\")\n\n        # check if the two images can be added or not\n        if self.meta['date'] == other.meta['date']:\n            raise TypeError(\"only the images from two different days can be subtracted\")\n\n        if self.meta['instrument'] != other.meta['instrument']:\n            raise TypeError(\"only the images from the same instrument can be subtracted\")\n\n        xLowA, xHighA = self.meta['xcoords']\n        yLowA, yHighA = self.meta['ycoords']\n\n        xLowB, xHighB = other.meta['xcoords']\n        yLowB, yHighB = other.meta['ycoords']\n\n        xDist = abs(xLowA - xLowB)\n        yDist = abs(yLowA - yLowB)\n\n        maxX = max(abs(xHighB-xLowB), abs(xHighA-xLowA))\n        maxY = max(abs(yHighB-yLowB), abs(yHighA-yLowA))\n\n        if yDist >= maxY or xDist >= maxX:\n            raise TypeError(\"two images can not be subtracted because they have no overlap\")\n\n        # convert both of two image pixel data into earth coord\n        earthA = pixel_to_earth(self.data, self.meta)\n        earthB = pixel_to_earth(other.data, other.meta)\n\n        coordA = earthA['earthCoord']\n        coordB = earthB['earthCoord']\n\n        # specify the boundary of final combined result (top-left, bottom-right)\n        xLow, xHigh = min(xLowA, xLowB), max(xHighA, xHighB)\n        yLow, yHigh = min(yLowA, yLowB), max(yHighA, yHighB)\n\n        # do the add logic\n        dataA = np.zeros((int(yHigh - yLow), int(xHigh - xLow)))\n        dataB = np.zeros((int(yHigh - yLow), int(xHigh - xLow)))\n        dataA[int(yLowA-yLow):int(yHighA-yLow), int(xLowA-xLow):int(xHighA-xLow)] = coordA\n        dataB[int(yLowB-yLow):int(yHighB-yLow), int(xLowB-xLow):int(xHighB-xLow)] = coordB\n        data = dataA-dataB\n        finalData = data[int(max(yLowA-yLow, yLowB-yLow)):int(min(yHighA-yLow, yHighB-yLow)), int(max(xLowA-xLow, xLowB-xLow)):int(min(xHighA-xLow, xHighB-xLow))]\n\n        finalData = earth_to_pixel(finalData, self.meta)\n\n        # create the new SatMap instance to store the result\n        shape = finalData.shape\n        fov = (xHigh - xLow, yHigh - yLow)\n        centre = ((xHigh+xLow)/2, (yHigh+yLow)/2)\n\n        now = datetime.now()\n\n        meta = dict()\n        meta['archive'] = self.meta['archive']\n        meta['year'] = now.year\n        meta['observatory'] = self.meta['observatory']\n        meta['instrument'] = self.meta['instrument']\n        meta['date'] = now.date()\n        meta['time'] = now.time()\n        meta['xcoords'] = [max(xLowA, xLowB), min(xHighA, xHighB)]\n        meta['ycoords'] = [max(yLowA, yLowB), min(yHighA, yHighB)]\n        meta['resolution'] = self.meta['resolution']\n        # add the extra property, indicating the source of the image (add/subtract/mosaic/origin)\n        meta['source'] = \"subtract\"\n\n        # return the new SatMap instance\n        return SatMap(meta, data, shape, fov, centre)\n\n    def mosaic(self, other: 'SatMap', resolution: int = None, padding: bool = True) -> 'SatMap':\n        \"\"\"allow to combine images as when using + but allowing mixing instruments with different resolution\n\n        Parameters\n        ----------\n        other: SatMap\n               Another image which do the mosaic operation with current image\n\n        resolution: int, optional\n                    If the resolution is not provided it should use the one of the two satmaps with larger detail, and\n                    expand the other to that level.\n\n        padding: bool, optional\n                 padding should be True by default, i.e., to return an image with blanks (NaNs) on it. However, if\n                 padding is set as False the resultant image should only cover maximum portion without blanks on the\n                 image. Besides, if padding is False, then two images must overlap with each other\n\n        Returns\n        -------\n        result: SatMap\n                the image created by doing the mosaic operation on two input images\n        \"\"\"\n\n        # error raising: query using wrong data format\n        if type(other) != SatMap:\n            raise TypeError(\"The attribute other must be a SatMap instance.\")\n\n        if resolution and type(resolution) != int:\n            raise TypeError(\"The attribute resolution must be an integer.\")\n\n        if padding and type(padding) != bool:\n            raise TypeError(\"The attribute padding must be a boolean value.\")\n\n        # allow to combine images as when using + but allowing mixing instruments (with different resolution!).\n\n        # check if the two images can be added or not\n        if self.meta['date'] != other.meta['date']:\n            raise Exception(\"only the images from the same day can be added\")\n\n        # get the rescale factor for both images\n        resolution = float(resolution) if resolution is not None else max(float(self.meta['resolution']), float(other.meta['resolution']))\n        factorA = self.meta['resolution'] / resolution\n        factorB = other.meta['resolution'] / resolution\n\n        # rescale the pixelA and pixelB, to uniform their resolution\n        pixelA = rescale(self.data, factorA) if factorA <= 1 else downscale_local_mean(self.data, (factorA, factorA))\n        pixelB = rescale(other.data, factorB) if factorB <= 1 else downscale_local_mean(other.data, (factorB, factorB))\n\n        # then execute the identical logic as the + operation\n        # convert both of two image pixel data into earth coord\n        earthA = pixel_to_earth(pixelA, self.meta, resolution)\n        earthB = pixel_to_earth(pixelB, other.meta, resolution)\n\n        # todo Note that changes in resolution may necessitate changes in field-of-view.\n        #  In this case, your code should raise an appropriate exception (NOT SURE HOW TO DO)\n\n        coordA = earthA['earthCoord']\n        coordB = earthB['earthCoord']\n\n        # specify the boundary of final combined result (top-left, bottom-right)\n        xLowA, xHighA = self.meta['xcoords']\n        yLowA, yHighA = self.meta['ycoords']\n\n        xLowB, xHighB = other.meta['xcoords']\n        yLowB, yHighB = other.meta['ycoords']\n\n        if not padding:\n            xDist = abs(xLowA - xLowB)\n            yDist = abs(yLowA - yLowB)\n\n            maxX = max(abs(xHighB-xLowB), abs(xHighA-xLowA))\n            maxY = max(abs(yHighB-yLowB), abs(yHighA-yLowA))\n\n            if yDist >= maxY or xDist >= maxX:\n                raise Exception(\"cannot perform mosaic without padding on these two images because they have no overlap\")\n\n        # the xcoord and ycoord choice differs depending on the padding\n        if not padding:\n            xLow, xHigh = min(xLowA, xLowB), max(xHighA, xHighB)\n            yLow, yHigh = max(yLowA, yLowB), min(yHighA, yHighB)\n        else:\n            xLow, xHigh = min(xLowA, xLowB), max(xHighA, xHighB)\n            yLow, yHigh = min(yLowA, yLowB), max(yHighA, yHighB)\n\n        # do the add logic\n        data = np.zeros((int(yHigh - yLow), int(xHigh - xLow)))\n        data[int(yLowA-yLow):int(yHighA-yLow), int(xLowA-xLow):int(xHighA-xLow)] = coordA\n        data[int(yLowB-yLow):int(yHighB-yLow), int(xLowB-xLow):int(xHighB-xLow)] = coordB\n        data = earth_to_pixel(data, self.meta)\n\n        # create the new SatMap instance to store the result\n        shape = data.shape\n        fov = (xHigh - xLow, yHigh - yLow)\n        centre = ((xHigh+xLow)/2, (yHigh+yLow)/2)\n\n        now = datetime.now()\n\n        meta = dict()\n        meta['archive'] = self.meta['archive']\n        meta['year'] = now.year\n        meta['observatory'] = self.meta['observatory']\n        meta['instrument'] = self.meta['instrument'] + ' + ' + other.meta['instrument']\n        meta['date'] = now.date()\n        meta['time'] = now.time()\n        meta['xcoords'] = [xLow, xHigh]\n        meta['ycoords'] = [yLow, yHigh]\n        meta['resolution'] = resolution\n        # add the extra property, indicating the source of the image (add/subtract/mosaic/origin)\n        meta['source'] = \"mosaic\"\n\n        # return the new SatMap instance\n        return SatMap(meta, data, shape, fov, centre)\n\n    def visualise(self, save: bool = False, savepath: Union[Path, str] = os.getcwd(), **kwargs):\n        \"\"\" visualise the image, show the axis as in earth coordinates and with the proper orientation of the image.\n\n        Parameters\n        ----------\n        save: bool, optional\n               If save is set to True, then the image should not be displayed on the screen and saved in the required\n               path\n\n        savepath: Union[Path, str], optional\n                the required saved path, if not set, the savepath will be the current directory\n\n\n        Notes\n        -----\n        the saved image is titled with the following pattern: {observatory}_{instrument}_{date}_{time}{_source}.png,\n        where the date and time are formatted as YYYYmmdd (e.g., 20221231) and HHMMSS (e.g., 120034) respectively, the\n        source has four different values: add/subtract/mosaic/origin, each indicate how that image is generated.\n        \"\"\"\n\n        # error raising: query using wrong data format\n        if save and type(save) != bool:\n            raise TypeError(\"The attribute save must be a boolean value.\")\n\n        if savepath and type(savepath) != str and type(savepath) != Path:\n            raise TypeError(\"The attribute savepath must be either a string or a Path instance.\")\n\n        # Show the axis as in earth coordinates and with the proper orientation of the image.\n\n        # get the self.data as the pixel coord, and convert it to earth coord\n        earth = pixel_to_earth(self.data, self.meta)\n        earthArray = earth['earthCoord']\n\n        xLow, xHigh = list(self.meta['xcoords'])\n        yLow, yHigh = list(self.meta['ycoords'])\n\n        resolution = int(self.meta['resolution'])\n\n        xDist = xHigh - xLow\n        yDist = yHigh - yLow\n\n        fig = plt.figure(figsize=(xDist/(1.2*resolution), yDist/(1.2*resolution)))\n        plt.imshow(earthArray, cmap='Blues', origin='lower')\n        plt.colorbar()\n        plt.yticks(np.arange(0, yHigh - yLow, resolution), np.arange(yLow, yHigh, resolution))\n        plt.xticks(np.arange(0, xHigh - xLow, resolution), np.arange(xLow, xHigh, resolution), rotation=270)\n\n        if save:\n            # if save=True, save the graph:\n            observatory = str(self.meta['observatory'])\n            instrument = str(self.meta['instrument'])\n            source = str(self.meta.get(\"source\", \"origin\"))\n            date = \"\".join(str(self.meta['date']).split('-'))\n\n            time = str(self.meta['time'])\n            time = time[:8] if len(time) >= 8 else time\n            time = \"\".join(time.split(\":\"))\n\n            title = \"_\".join([observatory, instrument, date, time, source])\n\n            path = os.path.join(savepath, title)\n            plt.savefig(path)\n        else:\n            # otherwise, show the graph\n            plt.show()\n\n\ndef get_satmap(file_name) -> 'SatMap':\n    # Give the name of the file, and return the data and meta,\n    #  where data gives the array, meta gives a dictionary with the metadata of the file.\n    # Raise Error:\n\n    # Errors:\n    if type(file_name) != str:\n        raise TypeError(\"The file-name must be a string\")\n\n\n    filetype = os.path.splitext(file_name)[1]  # obtain file extension\n\n    if filetype != '.asdf' \\\n            and filetype != '.hdf5' \\\n            and filetype != '.zip':\n        raise NameError(\"The file format is not supported. Only these are accepted: ASDF, HDF5 and ZIP.\")\n\n\n    if not Path(file_name).exists(): # if no such path/file exists\n        raise FileNotFoundError(\"The input file does not exist.\")\n\n\n\n\n\n\n    \n    # the attributes of the SatMap class:\n    meta = read(file_name)[1]\n    data = read(file_name)[0]\n    shape = np.shape(data)\n    theFov = fov(meta)\n    theCentre = centre(meta)\n\n    return SatMap(meta, data, shape, theFov, theCentre)\n\n\n# FUNCTIONS FOR THE ATTRIBUTES OF THE SatMap function:\ndef fov(meta):\n    \"\"\"Field of view of the images captured by the instrument (i.e., the difference between the boundaries).\n\n    Parameters\n    ----------\n\n    meta: dict\n         Meta data of the measurements taken by the instrument.\n\n    Returns\n    -------\n    fov: tuple\n         The range of x-coordinates and range of y-coordinates (i.e the field of view).\n    \"\"\"\n\n    x_min_max, y_min_max = meta['xcoords'], meta['ycoords']\n    fov = (x_min_max[1] - x_min_max[0], y_min_max[1] - y_min_max[0])\n\n    return fov\n\n\ndef centre(meta):\n    \"\"\"Centre of the image taken by the instrument.\n\n    Parameters\n    ----------\n\n    meta: dict\n          Meta data of the measurements taken by the instrument.\n\n    Returns\n    -------\n    centre: tuple\n            Coordinates of the centre of the image.\n    \"\"\"\n\n    # ERROR MESSAGE:\n    for i in query: assert (np.size(i['xcoords']) == 2 and np.size(i['ycoords']) == 2)  # test for shape of x and y coordinate range\n\n    x_min_max, y_min_max = meta['xcoords'], meta['ycoords']\n\n    centre = ((x_min_max[1] + x_min_max[0]) / 2, (y_min_max[1] - y_min_max[0]) / 2)\n\n    return centre\n\n\n# query = net.query_isa(\"2023-01-10\", \"2023-01-13\", 'manannan')\n# net.download_isa(query[0]['filename'])\n# satmap = get_satmap(query[0]['filename'])\n# #satmap = get_satmap(\"aigean_man_20221206_181924.hdf5\")\n# print(satmap.meta)\n# print(satmap.shape)\n\n\n\n\n# query = net.query_isa(\"2023-01-10\", \"2023-01-13\", 'lir')\n# net.download_isa(query[0]['filename'])\n# satmap = get_satmap(query[0]['filename'])\n# #satmap = get_satmap(\"aigean_lir_20221205_191610.asdf\")\n# print(satmap.meta)\n# print(satmap.shape)\n\n\n\n\n# query = net.query_isa(\"2023-01-10\", \"2023-01-13\", 'fand')\n# net.download_isa(query[0]['filename'])\n# satmap = get_satmap(query[0]['filename'])\n# #satmap = get_satmap(\"aigean_fan_20221206_190424.zip\")\n# print(satmap.meta)\n# print(satmap.shape)\n\n# print(satmap.data)\n# print(satmap.shape)\n# print(satmap.fov)\n# print(satmap.centre)\n\n\n# print(type(satmap.meta))\n# print(type(satmap.data))\n# print(type(satmap.shape))\n# print(type(satmap.fov))\n# print(type(satmap.centre))\n\n\n#print(net.query_isa(\"2022-12-20\", \"2022-12-23\", 'lir'))\n\n#print(net.query_isa(\"2022-12-29\", \"2022-12-31\", 'manannan'))\n# if query == None:\n#     print(\"ok\")\n#print(type(query))\n#net.download_isa(query[0]['filename'])\n\n\n\n# query = net.query_isa(\"2023-01-01\", \"2023-01-04\", 'lir')\n# #print(query)\n# net.download_isa(query[0]['filename'])\n\n# query = net.query_isa(\"2023-01-01\", \"2023-01-04\", 'lir')\n# #print(query)\n# net.download_isa(query[0]['filename'])\n\nquery = query_isa(\"2022-12-02\", \"2022-12-05\", 'lir')\ndownload_isa(query[0]['filename'])\nsatmap = get_satmap(query[0]['filename'])\n\nprint(satmap.centre)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/aigeanpy/satmap.py b/aigeanpy/satmap.py
--- a/aigeanpy/satmap.py	(revision 13f066276d4d406dd5296d0930140a8c4c41c3ff)
+++ b/aigeanpy/satmap.py	(date 1674145733073)
@@ -519,8 +519,8 @@
 # #print(query)
 # net.download_isa(query[0]['filename'])
 
-query = query_isa("2022-12-02", "2022-12-05", 'lir')
-download_isa(query[0]['filename'])
-satmap = get_satmap(query[0]['filename'])
+#query = query_isa("2022-12-02", "2022-12-05", 'lir')
+#download_isa(query[0]['filename'])
+#satmap = get_satmap(query[0]['filename'])
 
-print(satmap.centre)
\ No newline at end of file
+#print(satmap.centre)
\ No newline at end of file
